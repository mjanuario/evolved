<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Sampling alleles, genetic drift and effective population size • evolved</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Sampling alleles, genetic drift and effective population size">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">evolved</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Released version">1.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../index.html"><span class="fa fa-home"></span> Home</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html"><span class="fa fa-book"></span> Reference</a></li>
<li class="nav-item"><a class="nav-link" href="../articles/index.html"><span class="fa fa-book-open"></span> Vignettes &amp; Tutorials</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html"><span class="fa fa-newspaper"></span> News</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/mjanuario/evolved" aria-label="GitHub repository"><span class="fa fa-github"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Sampling alleles, genetic drift and effective population size</h1>
                        <h4 data-toc-skip class="author">Matheus
Januario, Andressa Viol, and Daniel Rabosky</h4>
            
            <h4 data-toc-skip class="date">Jan 2024</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/mjanuario/evolved/blob/HEAD/vignettes/popgen_drift.Rmd" class="external-link"><code>vignettes/popgen_drift.Rmd</code></a></small>
      <div class="d-none name"><code>popgen_drift.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="learning-objectives">Learning objectives<a class="anchor" aria-label="anchor" href="#learning-objectives"></a>
</h2>
<ol style="list-style-type: decimal">
<li>Genetic drift: qualitative expectation</li>
<li>Genetic drift: building intuition</li>
<li>Dissecting the variability in outcomes</li>
<li>Genetic drift and heterozygosity decay</li>
<li>Effective population size</li>
<li>Historical note</li>
</ol>
<hr>
<p>For this tutorial, you must install the <code>plot3D</code> R
package.</p>
<pre><code><span><span class="fu"><a href="https://rdrr.io/r/utils/install.packages.html" class="external-link">install.packages</a></span><span class="op">(</span><span class="st">"plot3D"</span><span class="op">)</span></span></code></pre>
<p>Then, you must load it, as well as our package:</p>
<pre><code><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/mjanuario/evolved" class="external-link">evolved</a></span><span class="op">)</span></span>
<span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va">plot3D</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Let's also store our par() configs so </span></span>
<span><span class="co"># we can restore them whenever we change it in this tutorial</span></span>
<span><span class="va">oldpar</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>no.readonly <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>  </span></code></pre>
</div>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>In previous labs, we introduced a simple way of applying probability
rules to allele change through a small number of generations. In this
lab, we will extrapolate qualitatively and quantitatively from those
insights, and see what happens to genetic diversity over time.</p>
</div>
<div class="section level2">
<h2 id="genetic-drift-qualitative-expectation">Genetic drift: qualitative expectation<a class="anchor" aria-label="anchor" href="#genetic-drift-qualitative-expectation"></a>
</h2>
<p>As you may know, Peter Buri did an experiment on genetic drift in
1956. He started with many flask populations of <em>Drosophila
melanogaster</em> and applied a very simple method to keep track of
genetic drift. In his own words (Buri, 1956):</p>
<p><em>“The method consists in observations on the changes in gene
frequency between generations in each of a large number of small
cultures in which the size of the breeding population is controlled.
Each initial culture founds a line in which each successive generation
is initiated with a random sample of uniform size taken from among the
flies of the preceding generation. The form is that of a fairly large
experimental population divided into a number of very small completely
isolated subunits.”</em></p>
<p>Thus, the experiment involves sampling adults at random from a flask
and placing them in a new flask where they will mate. Their offspring
reach adulthood and are then themselves sampled, thus producing a new
generation. All the while, we keep track of relative frequencies of
genotypes through time.</p>
<p>Now, imagine you are in Buri’s lab and will run his experiment using
1000 flasks (he tracked 212 in total). When individuals from a flask
become able to reproduce, you randomly and uniformly (i.e. all
individuals are equally likely to be sampled) pick 8 virgin females
<em>from the same flask and generation</em> to mate only once with 8
random males from the same flask and generation. Each mating is
successful and generates many viable offspring.</p>
<p>Assume males and females do not diverge in genotypic frequencies.
Recall also that <em>Drosophila melanogaster</em> is a diploid
organism.</p>
<p>If you are not familiar with inserting an image into an RMarkdown
file:</p>
<p>First, make sure your image is inside the current working directory,
i.e. inside the reference folder that R will use when you knit the
RMarkdown file. Then, you can use the following syntax, replacing
<code>file_name.jpg</code> with the specific name of your image.</p>
<pre><code>![](file_name.jpg)</code></pre>
<hr>
</div>
<div class="section level2">
<h2 id="genetic-drift-building-intuition">Genetic drift: building intuition<a class="anchor" aria-label="anchor" href="#genetic-drift-building-intuition"></a>
</h2>
<p>Now we will do a computer simulation of what Buri did. We will use
the <code><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom()</a></code> function to draw allele counts from a
population of a diploid organism through time. The function does this by
applying the following algorithm:</p>
<ol style="list-style-type: decimal">
<li>Start with a certain probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
of sampling a specific allele (e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mn>1</mn></msub><annotation encoding="application/x-tex">A_1</annotation></semantics></math>)
based on that allele’s frequency in the population.</li>
<li>Generate the next generation by taking random draws from a binomial
distribution given probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
of sampling copies of allele
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mn>1</mn></msub><annotation encoding="application/x-tex">A_1</annotation></semantics></math>.</li>
<li>Recalculate the new allele frequency. You have just observed
drift!</li>
</ol>
<p>Remember that the binomial distribution applies to binary processes
and their number of “successes”. Our binary process here is the sampling
of alleles – as the organisms are diploid, each of their 2 alleles will
either be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mn>1</mn></msub><annotation encoding="application/x-tex">A_1</annotation></semantics></math>
or
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mn>2</mn></msub><annotation encoding="application/x-tex">A_2</annotation></semantics></math>,
with no exceptions. Our number of “successes” is the total number of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mn>1</mn></msub><annotation encoding="application/x-tex">A_1</annotation></semantics></math>
alleles (i.e., the allele frequency,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>)
in the next flask.</p>
<p>So, a single flask in the first generation of our experiment can be
simulated as:</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">N</span> <span class="op">&lt;-</span> <span class="fl">32</span> <span class="co">#population size</span></span>
<span><span class="va">n_alleles</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">*</span><span class="va">N</span> </span>
<span><span class="va">p_gen0</span> <span class="op">&lt;-</span> <span class="fl">0.25</span> <span class="co">#Frequency of allele A1 in the first gen</span></span>
<span><span class="va">p_gen1</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">n_alleles</span>, <span class="va">p_gen0</span><span class="op">)</span> <span class="op">/</span> <span class="va">n_alleles</span></span>
<span><span class="va">p_gen1</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.171875</span></span></code></pre>
<p>Now, to do the next generation, we just have to redo this process,
but this time using
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mn>1</mn></msub><annotation encoding="application/x-tex">p_1</annotation></semantics></math>,
the allele frequency in generation 1, as the new probability of sampling
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mn>1</mn></msub><annotation encoding="application/x-tex">A_1</annotation></semantics></math>
alleles:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">p_gen2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">n_alleles</span>, <span class="va">p_gen1</span><span class="op">)</span> <span class="op">/</span> <span class="va">n_alleles</span></span>
<span><span class="va">p_gen2</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.21875</span></span></code></pre>
<p>What would the third generation be then?</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">p_gen3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">n_alleles</span>, <span class="va">p_gen2</span><span class="op">)</span> <span class="op">/</span> <span class="va">n_alleles</span></span>
<span><span class="va">p_gen3</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.234375</span></span></code></pre>
<p>The fourth would be:</p>
<div class="sourceCode" id="cb10"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">p_gen4</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">n_alleles</span>, <span class="va">p_gen3</span><span class="op">)</span> <span class="op">/</span> <span class="va">n_alleles</span></span>
<span><span class="va">p_gen4</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.1875</span></span></code></pre>
<p>The fifth would be:</p>
<div class="sourceCode" id="cb12"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">p_gen5</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">n_alleles</span>, <span class="va">p_gen4</span><span class="op">)</span> <span class="op">/</span> <span class="va">n_alleles</span></span>
<span><span class="va">p_gen5</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.078125</span></span></code></pre>
<p>What is happening with the <em>code</em> and with the <em>result</em>
at each generation?</p>
<p>Let’s plot all results we have up to now. Note that your results will
be different because you are generating different random numbers than us
here.</p>
<div class="sourceCode" id="cb14"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">generations</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">0</span>, to <span class="op">=</span> <span class="fl">5</span>, by <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span>
<span><span class="va">p_through_time</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">p_gen0</span>, <span class="va">p_gen1</span>, <span class="va">p_gen2</span>, <span class="va">p_gen3</span>, <span class="va">p_gen4</span>, <span class="va">p_gen5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="va">generations</span>, <span class="va">p_through_time</span>, type<span class="op">=</span><span class="st">"l"</span>, lwd <span class="op">=</span> <span class="fl">2</span>, col <span class="op">=</span> <span class="st">"darkorchid3"</span>,</span>
<span>     ylab <span class="op">=</span> <span class="st">"p"</span>, xlab <span class="op">=</span> <span class="st">"generations"</span>, las <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p><img src="popgen_drift_files/figure-html/unnamed-chunk-7-1.png" width="700"></p>
<p>Repeat the above lines of code a few times to get a feeling for what
is happening. Do all simulations behave the same way? Can you identify
different “archetypes” of dynamics?</p>
<p>Instead of tediously copying and pasting code in the console, we can
run large numbers of simulations quite easily using the function
<code><a href="../reference/WFDriftSim.html">WFDriftSim()</a></code>:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#We will simulate five flasks through 10 generations:</span></span>
<span><span class="fu"><a href="../reference/WFDriftSim.html">WFDriftSim</a></span><span class="op">(</span>Ne <span class="op">=</span> <span class="fl">32</span>, n.gen <span class="op">=</span> <span class="fl">10</span>, p0 <span class="op">=</span> <span class="fl">0.5</span>, n.sim <span class="op">=</span> <span class="fl">5</span><span class="op">)</span></span></code></pre></div>
<p>Run the above chunk of code above many times to get a feeling for it.
How does changing <code>Ne</code>, <code>n.gen</code>, <code>p0</code>,
and <code>n.sim</code> affect your simulations?</p>
<p>A function to calculate if a simulation’s alleles have fixed.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># R will not return anything in the console when you run this, but </span></span>
<span><span class="co"># after running you should have this function in your R session</span></span>
<span><span class="co"># as an object. Note that if you name another object as "isFixed"</span></span>
<span><span class="co"># the function will be overwritten.</span></span>
<span></span>
<span><span class="va">isFixed</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">p</span>, <span class="va">tol</span> <span class="op">=</span> <span class="fl">0.00000000001</span><span class="op">)</span><span class="op">{</span></span>
<span>    </span>
<span>    <span class="kw">if</span> <span class="op">(</span><span class="va">p</span> <span class="op">&lt;=</span> <span class="va">tol</span> <span class="op">|</span> <span class="va">p</span> <span class="op">&gt;=</span> <span class="op">(</span><span class="fl">1</span> <span class="op">-</span> <span class="va">tol</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>        <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="cn">TRUE</span><span class="op">)</span></span>
<span>    <span class="op">}</span> <span class="kw">else</span><span class="op">{</span></span>
<span>        <span class="kw"><a href="https://rdrr.io/r/base/function.html" class="external-link">return</a></span><span class="op">(</span><span class="cn">FALSE</span><span class="op">)</span></span>
<span>    <span class="op">}</span></span>
<span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Assuming your current allele frequency is stored in the p_t object, the</span></span>
<span><span class="co"># line below uses the function created above to test if p_t is equal to </span></span>
<span><span class="co"># zero OR equal to one</span></span></code></pre></div>
<pre><code><span><span class="fu">isFixed</span><span class="op">(</span><span class="va">p_t</span><span class="op">)</span></span></code></pre>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># The function will return `TRUE` if p_t is equal to zero or one.</span></span></code></pre></div>
<hr>
<div class="section level3">
<h3 id="dissecting-the-variability-in-outcomes">Dissecting the variability in outcomes<a class="anchor" aria-label="anchor" href="#dissecting-the-variability-in-outcomes"></a>
</h3>
<p>If our simulations contain many independent flasks (i.e. when
<code>n.sim</code> &gt; 40), it is hard to keep track of the whole
history of allele frequency change in each flask. This is when the
histogram to the right of the line plot in the output of
<code>WFDriftSim</code> becomes particularly helpful. Take a look at the
histogram section of the output plot after typing the following into
your console:</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="../reference/WFDriftSim.html">WFDriftSim</a></span><span class="op">(</span>Ne <span class="op">=</span> <span class="fl">32</span>, n.gen <span class="op">=</span> <span class="fl">10</span>, p0 <span class="op">=</span> <span class="fl">0.5</span>, n.sim <span class="op">=</span> <span class="fl">100</span><span class="op">)</span></span></code></pre></div>
<p><img src="Buri_1956_fig6_wout_axes.png" width="437"></p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="genetic-drift-and-heterozygosity-decay">Genetic drift and heterozygosity decay<a class="anchor" aria-label="anchor" href="#genetic-drift-and-heterozygosity-decay"></a>
</h2>
<p>In lecture, we learned an analytic formula to calculate
heterozygosity decay over time due to drift.</p>
<p>Example on how to store (and handle) your simulation results:</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">data</span> <span class="op">=</span> <span class="fu"><a href="../reference/WFDriftSim.html">WFDriftSim</a></span><span class="op">(</span>Ne <span class="op">=</span> <span class="fl">8</span>, n.gen <span class="op">=</span> <span class="fl">50</span>, p0 <span class="op">=</span> <span class="fl">0.5</span>, n.sim <span class="op">=</span> <span class="fl">50</span>,</span>
<span>                  print.data <span class="op">=</span> <span class="cn">T</span>, plot.type <span class="op">=</span> <span class="st">"none"</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#then, if we want to see the 2nd to 5th generations of </span></span>
<span><span class="co"># the simulations number 14, 17 and 18, we type:</span></span>
<span><span class="va">sims</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">14</span>,<span class="fl">17</span>,<span class="fl">18</span><span class="op">)</span></span>
<span><span class="va">gens</span> <span class="op">&lt;-</span> <span class="fl">3</span><span class="op">:</span><span class="fl">6</span></span>
<span><span class="va">subset_data</span> <span class="op">&lt;-</span> <span class="va">data</span><span class="op">[</span><span class="va">sims</span>, <span class="va">gens</span><span class="op">]</span></span>
<span><span class="va">subset_data</span></span></code></pre></div>
<pre><code><span><span class="co">##         gen2   gen3   gen4   gen5</span></span>
<span><span class="co">## sim14 0.4375 0.3125 0.3125 0.3125</span></span>
<span><span class="co">## sim17 0.5625 0.8125 0.8125 0.6875</span></span>
<span><span class="co">## sim18 0.1875 0.1250 0.0625 0.0000</span></span></code></pre>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#and we can also plot those results:</span></span>
<span></span>
<span><span class="co">#first opening an empty plot:</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="cn">NA</span>, ylab <span class="op">=</span> <span class="st">"Alleleic frequency"</span>, xlab <span class="op">=</span> <span class="st">"Generation"</span>,</span>
<span>     xlim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>, <span class="fl">5</span><span class="op">)</span>, ylim <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">1</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#creating a set of colors to paint our lines</span></span>
<span><span class="va">cols</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/grDevices/palettes.html" class="external-link">rainbow</a></span><span class="op">(</span>n <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">subset_data</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#then we finally add the lines to our plot:</span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">i</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">subset_data</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">gens</span> <span class="op">-</span> <span class="fl">1</span>, y <span class="op">=</span> <span class="va">subset_data</span><span class="op">[</span><span class="va">i</span>,<span class="op">]</span>, col <span class="op">=</span> <span class="va">cols</span><span class="op">[</span><span class="va">i</span><span class="op">]</span><span class="op">)</span></span>
<span><span class="op">}</span></span></code></pre></div>
<p><img src="popgen_drift_files/figure-html/unnamed-chunk-13-1.png" width="700"></p>
<p>Notice that the actual generation number does not match the column
numbers!</p>
<hr>
</div>
<div class="section level2">
<h2 id="effective-population-size">Effective population size<a class="anchor" aria-label="anchor" href="#effective-population-size"></a>
</h2>
<p>We know that in real populations, the census size might be different
from the effective population size.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mi>e</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mfrac><mn>1</mn><mi>t</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>t</mi></munderover><mfrac><mn>1</mn><msub><mi>N</mi><mi>i</mi></msub></mfrac></mrow></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}
N_e = \frac{1}{\frac{1}{t}\sum_{i=1}^t \frac{1}{N_i}}
\end{equation}</annotation></semantics></math></p>
<p><img src="popgen_drift_files/figure-html/unnamed-chunk-14-1.png" width="700"></p>
<div class="section level3">
<h3 id="some-food-for-thought">Some food for thought:<a class="anchor" aria-label="anchor" href="#some-food-for-thought"></a>
</h3>
<p>Assuming an equal number of females and males, an equal number of
generations, and bottlenecks of equal magnitude (equally drastic changes
in census size), which of the options below has the greatest influence
on
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mi>e</mi></msub><annotation encoding="application/x-tex">N_e</annotation></semantics></math>
given equation (1)? Why?</p>
<ol style="list-style-type: upper-alpha">
<li>Having a large census size <em>prior</em> to the bottleneck</li>
<li>Experiencing a bottleneck that is very brief</li>
<li>Having a large census size <em>after</em> the bottleneck</li>
</ol>
<p>A nice in-depth discussion of what the effective population size
means can be found in Waples (2022).</p>
<hr>
</div>
</div>
<div class="section level2">
<h2 id="historical-note">Historical note<a class="anchor" aria-label="anchor" href="#historical-note"></a>
</h2>
<p>Kimura’s (1955) diffusion approximation for the distribution of
allele frequencies in populations under drift is both elegant and
difficult. Understanding his derivation requires some fairly
sophisticated mathematics. However, there is a much easier way to
generate and visualize the expectation for the distribution of allele
frequencies across populations under drift, if we assume the population
size is reasonably small. The solution described below involves a Markov
chain model of drift.</p>
<p>Fundamentally, the probability model we will use is a binomial
sampling model. This is nothing more than the “coin-toss” distribution:
what is the probability of getting (say)
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
heads out of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
coin tosses, given that the probability of heads on any given toss is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>?
More formally we denote this probability by
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="prefix">|</mo><mi>n</mi><mo>;</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P(k|n; p)</annotation></semantics></math>.</p>
<p>Under a binomial sampling model, we can estimate the probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="prefix">|</mo><mi>n</mi><mo>;</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">P(k|n; p)</annotation></semantics></math>
using the binomial probability, or:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>k</mi><mo stretchy="false" form="prefix">|</mo><mi>n</mi><mo>;</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>n</mi><mi>k</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>p</mi><mi>k</mi></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>n</mi><mo>−</mo><mi>k</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{equation}
P(k | n; p) = \binom{n}{k} p^k (1-p)^{n-k}
\end{equation}</annotation></semantics></math></p>
<p>Let’s say we have a population with alleles
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>a</mi><annotation encoding="application/x-tex">a</annotation></semantics></math>,
with respective frequencies
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">1 - p</annotation></semantics></math>.
The relationship between the binomial model and genetic drift is that,
for a finite population, we can use this to compute the exact
probability that we will sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
alleles of a given type in a given generation, given an initial
frequency
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>.
So, for example, consider Buri’s genetic drift data, where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">2N = 32</annotation></semantics></math>,
and where the initial allele frequencies were equal
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">p = 0.5</annotation></semantics></math>).
Given this starting configuration at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>0</mn></msub><annotation encoding="application/x-tex">t_0</annotation></semantics></math>
(e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">n = 32</annotation></semantics></math>,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">p = 0.5</annotation></semantics></math>),
we can use the binomial probability to compute the exact probability of
sampling
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
alleles in generation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>t</mi><mn>1</mn></msub><annotation encoding="application/x-tex">t_1</annotation></semantics></math>.</p>
<p>I’m going to switch notation here. For shorthand, I’m going to use
the expression
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mi>i</mi><mo>,</mo><mi>k</mi></mrow></msub><annotation encoding="application/x-tex">P_{i, k}</annotation></semantics></math>
to denote the probability that a population with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
alleles has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
copies after one generation of drift (sampling). This necessarily
depends on a particular population size. For example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mn>13</mn><mo>,</mo><mn>16</mn></mrow></msub><annotation encoding="application/x-tex">P_{13, 16}</annotation></semantics></math>
is the probability that a given generation of random mating in a
Wright-Fisher population gives 13
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
alleles given that the population currently has 16 such alleles, but
obviously, this probability is critically dependent on the population
size. For the Buri data, with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">2N = 32</annotation></semantics></math>,
the probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mn>13</mn><mo>,</mo><mn>16</mn></mrow></msub><annotation encoding="application/x-tex">P_{13 , 16}</annotation></semantics></math>
corresponds to binomial parameters
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>0.5</mn></mrow><annotation encoding="application/x-tex">p = 0.5</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">n = 32</annotation></semantics></math>.
But this probability would obviously differ for any other
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>.</p>
<p>Now, imagine forming a matrix of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2N + 1</annotation></semantics></math>
columns and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2N + 1</annotation></semantics></math>
rows. Here, each element
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">(</mo><mi>i</mi><mo>,</mo><mi>k</mi><mo stretchy="true" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(i, k)</annotation></semantics></math>
gives the probability – the <em>transition probability</em> – associated
with sampling
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
alleles of type
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
in generation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t+1</annotation></semantics></math>
given that you are currently at
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
alleles in generation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>.
The matrix has
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2N + 1</annotation></semantics></math>
rows and columns because we also have an extra row and column to account
for the state of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
alleles.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>0</mn><mo>,</mo><mn>0</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>0</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>0</mn><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>1</mn><mo>,</mo><mn>0</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>1</mn><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>2</mn><mo>,</mo><mn>0</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>2</mn><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>3</mn><mo>,</mo><mn>0</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>3</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>3</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>3</mn><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>⋱</mo></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mi>n</mi><mo>,</mo><mn>0</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mi>n</mi><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mi>n</mi><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mi>n</mi><mo>,</mo><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
P_{0,0} &amp; P_{0,1} &amp; P_{0,2}  &amp; \cdots &amp; P_{0, n}\\
P_{1,0} &amp; P_{1,1} &amp; P_{1,2}  &amp; \cdots &amp; P_{1, n}\\
P_{2,0} &amp; P_{2,1} &amp; P_{2,2}  &amp; \cdots &amp; P_{2, n}\\
P_{3,0} &amp; P_{3,1} &amp; P_{3,2}  &amp; \cdots &amp; P_{3, n}\\
\vdots &amp; \vdots   &amp; \vdots   &amp; \ddots &amp; \vdots \\ 
P_{n,0} &amp; P_{n,1} &amp; P_{n,2}  &amp; \cdots &amp; P_{n, n}\\
\end{bmatrix}</annotation></semantics></math></p>
<p>Of course, the probability of going from
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
alleles to any number of alleles greater than
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
is also
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
(because 0 is an absorbing state – after the allele is lost in the
population, it cannot increase in frequency). So the first column is
necessarily zero, with the exception of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mn>0</mn><mo>,</mo><mn>0</mn></mrow></msub><annotation encoding="application/x-tex">P_{0,0}</annotation></semantics></math>,
which is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>
(if you have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
alleles at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>,
you will have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
alleles at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t + 1</annotation></semantics></math>
with probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>).
The same general idea holds for the last column: if you are at the
maximum number of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
alleles, e.g.,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
alleles, then you can’t sample
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math>
in the following generation. In our example, with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">2N = 32</annotation></semantics></math>,
both
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>32</mn><annotation encoding="application/x-tex">32</annotation></semantics></math>
are absorbing states. So the matrix is:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="true" form="prefix">[</mo><mtable><mtr><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>0</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>0</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>1</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>1</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>2</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>2</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>3</mn><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mn>3</mn><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd><mtd columnalign="center" style="text-align: center"><mo>⋱</mo></mtd><mtd columnalign="center" style="text-align: center"><mi>⋮</mi></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"><mn>0</mn></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mi>n</mi><mo>,</mo><mn>1</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><msub><mi>P</mi><mrow><mi>n</mi><mo>,</mo><mn>2</mn></mrow></msub></mtd><mtd columnalign="center" style="text-align: center"><mi>⋯</mi></mtd><mtd columnalign="center" style="text-align: center"><mn>1</mn></mtd></mtr><mtr><mtd columnalign="center" style="text-align: center"></mtd></mtr></mtable><mo stretchy="true" form="postfix">]</mo></mrow><annotation encoding="application/x-tex">\begin{bmatrix}
1 &amp; P_{0,1} &amp; P_{0,2}  &amp; \cdots &amp; 0\\
0 &amp; P_{1,1} &amp; P_{1,2}  &amp; \cdots &amp; 0\\
0 &amp; P_{2,1} &amp; P_{2,2}  &amp; \cdots &amp; 0\\
0 &amp; P_{3,1} &amp; P_{3,2}  &amp; \cdots &amp; 0\\
\vdots &amp; \vdots   &amp; \vdots   &amp; \ddots &amp; \vdots \\ 
0 &amp; P_{n,1} &amp; P_{n,2}  &amp; \cdots &amp; 1\\
\end{bmatrix}</annotation></semantics></math></p>
<p>Let’s call this matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>.
It is a transition matrix, and it has some really nice properties. This
matrix includes the probabilities for all possible pairwise transitions
between states. As such, the columns of the matrix must sum to
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>1</mn><annotation encoding="application/x-tex">1</annotation></semantics></math>.
Once we’ve defined this matrix, we can fill in all of the individual
elements with binomial probabilities. So, for example, assuming
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>N</mi><mo>=</mo><mn>32</mn></mrow><annotation encoding="application/x-tex">2N = 32</annotation></semantics></math>,
we can fill in
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mrow><mn>3</mn><mo>,</mo><mn>5</mn></mrow></msub><annotation encoding="application/x-tex">P_{3, 5}</annotation></semantics></math>
by first noting that the frequency of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mfrac><mn>5</mn><mn>32</mn></mfrac></mrow><annotation encoding="application/x-tex">p = \frac{5}{32}</annotation></semantics></math>.</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mrow><mn>3</mn><mo>,</mo><mn>5</mn></mrow></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mn>32</mn><mn>3</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msup><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mn>5</mn><mn>32</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mn>3</mn></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mfrac><mn>5</mn><mn>32</mn></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mn>32</mn><mo>−</mo><mn>3</mn></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{equation}
P_{3,5} = \binom{32}{3} \binom{5}{32}^3 (1-\frac{5}{32})^{32-3}
\end{equation}</annotation></semantics></math></p>
<p>The amazing thing about the transition matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
is that we can use it to compute the distribution of alleles after a
generation of random mating, given some initial vector of allele counts
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mn>0</mn></msub><annotation encoding="application/x-tex">N_0</annotation></semantics></math>.
Here,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mn>0</mn></msub><annotation encoding="application/x-tex">N_0</annotation></semantics></math>
is a vector with the property that each element
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
of the vector gives the number of populations having
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>
alleles. For example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">[</mo><mn>0</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">N_0[0]</annotation></semantics></math>
gives the number of initial populations with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>0</mn><annotation encoding="application/x-tex">0</annotation></semantics></math><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
alleles. In the Buri data, with roughly 100 populations with equal
allele frequencies, we would have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>0</mn></msub><mrow><mo stretchy="true" form="prefix">[</mo><mn>16</mn><mo stretchy="true" form="postfix">]</mo></mrow><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">N_0[16] = 100</annotation></semantics></math>
(100 populations, each with 16
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
alleles at time
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">t = 0</annotation></semantics></math>)
and all other elements of the vector equal to zero.</p>
<p>We can now construct a Markov chain, to compute the probability
distribution of populations with a given allele count, as</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub><mo>=</mo><mi>P</mi><msub><mi>N</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
N_1 = PN_0
\end{equation}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><msub><mi>N</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">P N_0</annotation></semantics></math>
involves matrix multiplication of the column vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mn>0</mn></msub><annotation encoding="application/x-tex">N_0</annotation></semantics></math>
by the square matrix
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mn>1</mn></msub><annotation encoding="application/x-tex">N_1</annotation></semantics></math>
is the mean number of populations in each allele count category. For
example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mn>1</mn></msub><mrow><mo stretchy="true" form="prefix">[</mo><mn>7</mn><mo stretchy="true" form="postfix">]</mo></mrow></mrow><annotation encoding="application/x-tex">N_1[7]</annotation></semantics></math>
is the number of populations in generation
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>t</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">t = 1</annotation></semantics></math>
that have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>7</mn><annotation encoding="application/x-tex">7</annotation></semantics></math>
alleles (remember: the starting state was given by the vector
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mn>0</mn></msub><annotation encoding="application/x-tex">N_0</annotation></semantics></math>).
More generally, we have:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>P</mi><msub><mi>N</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
N_{t+1} = PN_t
\end{equation}</annotation></semantics></math></p>
<p>And we can see where this is going. It’s a recursive relationship
whereby:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>t</mi><mo>+</mo><mn>2</mn></mrow></msub><mo>=</mo><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>P</mi><msub><mi>N</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
N_{t+2} = P (P N_0)
\end{equation}</annotation></semantics></math></p>
<p>and</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>t</mi><mo>+</mo><mn>3</mn></mrow></msub><mo>=</mo><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>P</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>P</mi><msub><mi>N</mi><mn>0</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">\begin{equation}
N_{t+3} = P ( P (P N_0))
\end{equation}</annotation></semantics></math></p>
<p>Etc etc. Thus, computing the distribution of allele frequencies can
easily be done by iterating the equation given above, provided we have
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>N</mi><mn>0</mn></msub><annotation encoding="application/x-tex">N_0</annotation></semantics></math>.</p>
<p>The R code below implements this model and uses it to compute the
distribution of populations for each possible number of alleles, using
Buri’s <em>Drosophila</em> study as a guide.</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># A simple genetic drift simulator as a Markov process</span></span>
<span><span class="va">N</span>       <span class="op">&lt;-</span> <span class="fl">16</span></span>
<span><span class="va">popsize</span> <span class="op">&lt;-</span> <span class="fl">2</span><span class="op">*</span><span class="va">N</span></span>
<span></span>
<span><span class="co"># Now we define a transition matrix, such that:</span></span>
<span><span class="co"># Each element of the transition matrix is a transition probability</span></span>
<span><span class="co">#   Specifically: element Pi,j is the probability of going from</span></span>
<span><span class="co">#   j alleles to i alleles in a single sampling step </span></span>
<span><span class="co">#  </span></span>
<span></span>
<span><span class="va">tmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="fl">0</span>, nrow <span class="op">=</span> <span class="va">popsize</span> <span class="op">+</span> <span class="fl">1</span>, ncol <span class="op">=</span> <span class="va">popsize</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span> <span class="co"># along rows: current allele count; along cols: future allele count</span></span>
<span></span>
<span><span class="co"># Fill in elements with probabilities from the binomial distribution</span></span>
<span><span class="co"># If you have j alleles in generation t-1, then this defines the probability</span></span>
<span><span class="co"># of sampling (0,1....2N) alleles in the next generation, under a binomial </span></span>
<span><span class="co"># sampling process:</span></span>
<span></span>
<span><span class="co"># Note also that first column and row are absorbing states of 0</span></span>
<span></span>
<span><span class="co"># Here is the vector of frequencies:</span></span>
<span><span class="va">probvec</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">popsize</span><span class="op">)</span> <span class="op">/</span> <span class="va">popsize</span>  </span>
<span></span>
<span><span class="co"># What is the probability of getting to 0 allele copies, given </span></span>
<span><span class="co"># that you have 1? This is P01, and the transition probability </span></span>
<span><span class="co"># would be computed using 1/2N (=1/32) as the sampling probability </span></span>
<span><span class="co"># for the allele. </span></span>
<span><span class="co"># Here, this is computed using the function dbinom, which is a shortcut </span></span>
<span><span class="co">#   to the analytical binomial probability:</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">dbinom</a></span><span class="op">(</span><span class="fl">1</span>, <span class="va">popsize</span>, prob <span class="op">=</span> <span class="fl">1</span><span class="op">/</span><span class="fl">32</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.3737345</span></span></code></pre>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Now we will set up the full matrix by iterating this over rows:</span></span>
<span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">ii</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">nrow</a></span><span class="op">(</span><span class="va">tmat</span><span class="op">)</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="va">tmat</span><span class="op">[</span><span class="va">ii</span>, <span class="fl">2</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/nrow.html" class="external-link">ncol</a></span><span class="op">(</span><span class="va">tmat</span><span class="op">)</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">dbinom</a></span><span class="op">(</span><span class="va">ii</span> <span class="op">-</span> <span class="fl">1</span>, size <span class="op">=</span> <span class="va">popsize</span>, prob <span class="op">=</span> <span class="va">probvec</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Note: we ignore the first column and let almost all elements equal zero, </span></span>
<span><span class="co"># because the probability of sampling k alleles given that you currently have zero</span></span>
<span><span class="co"># is zero everywhere except the special case of P00, which is 1 </span></span>
<span><span class="co"># (if you have zero now, you will have zero in the next gen with probability 1)</span></span>
<span><span class="co"># To address this, we manually set element P00 equal to 1:</span></span>
<span><span class="va">tmat</span><span class="op">[</span><span class="fl">1</span>,<span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">1</span></span>
<span></span>
<span><span class="co">#Now, all the columns should sum to 1:</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/colSums.html" class="external-link">colSums</a></span><span class="op">(</span><span class="va">tmat</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1</span></span></code></pre>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Pt &lt;- tmat^2*P0 </span></span>
<span></span>
<span><span class="co"># Initial vector of population frequencies:</span></span>
<span><span class="co"># Like Buri, suppose we do an experiment with 100 populations</span></span>
<span><span class="co"># each with equal allele frequencies (p = q = 0.5) initially.</span></span>
<span><span class="va">p_init</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/rep.html" class="external-link">rep</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">popsize</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># note, in this indexing:</span></span>
<span><span class="co">#   p_init[1] is the number of populations with 0 alleles</span></span>
<span><span class="co">#   p_init[2] is the number with 1 allele</span></span>
<span><span class="co">#   p_init[popsize + 1] is the number with 2N alleles</span></span>
<span></span>
<span><span class="co"># we want the initial population to have 2N/2 = N p alleles (for 50:50 proportion of alleles)</span></span>
<span><span class="co">#  so we fill in the N+1 element of p_init vector with the </span></span>
<span><span class="co">#  number of populations</span></span>
<span></span>
<span><span class="va">p_init</span><span class="op">[</span><span class="va">N</span><span class="op">+</span><span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fl">100</span></span></code></pre></div>
<div class="sourceCode" id="cb28"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#Now, we will introduce drift in our simulation</span></span>
<span><span class="co"># after 1 generation of random mating in Wright-Fisher (WF) population, </span></span>
<span><span class="co">#  the distribution of populations is:</span></span>
<span><span class="va">tmat</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">p_init</span></span>
<span> </span>
<span><span class="co"># and after 2 generations, it is:</span></span>
<span><span class="va">tmat</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="op">(</span><span class="va">tmat</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">p_init</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># and after 3 generations, it is:</span></span>
<span><span class="va">tmat</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="op">(</span><span class="va">tmat</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="op">(</span><span class="va">tmat</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">p_init</span><span class="op">)</span><span class="op">)</span></span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># This is easy enough to iterate.</span></span>
<span><span class="co"># Here, we will make a matrix to hold </span></span>
<span><span class="co"># the results, for up to ngen generations</span></span>
<span></span>
<span><span class="va">ngen</span>    <span class="op">&lt;-</span> <span class="fl">20</span></span>
<span><span class="va">freqmat</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html" class="external-link">matrix</a></span><span class="op">(</span><span class="cn">NA</span>, nrow<span class="op">=</span><span class="va">popsize</span><span class="op">+</span><span class="fl">1</span>, ncol<span class="op">=</span><span class="va">ngen</span><span class="op">)</span></span>
<span></span>
<span><span class="va">curr_pop</span> <span class="op">&lt;-</span> <span class="va">p_init</span> </span>
<span></span>
<span><span class="kw">for</span> <span class="op">(</span><span class="va">ii</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="va">ngen</span><span class="op">)</span><span class="op">{</span></span>
<span>    </span>
<span>    <span class="co"># recompute the new pop frequency distribution</span></span>
<span>    <span class="va">curr_pop</span> <span class="op">&lt;-</span> <span class="va">tmat</span> <span class="op"><a href="https://rdrr.io/r/base/matmult.html" class="external-link">%*%</a></span> <span class="va">curr_pop</span></span>
<span>    <span class="co"># store it:</span></span>
<span>    <span class="va">freqmat</span><span class="op">[</span>,<span class="va">ii</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">curr_pop</span></span>
<span><span class="op">}</span></span>
<span></span>
<span></span>
<span></span>
<span><span class="fu">plot3D</span><span class="fu">::</span><span class="fu"><a href="https://rdrr.io/pkg/plot3D/man/persp3D.html" class="external-link">persp3D</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="va">probvec</span><span class="op">)</span>, z<span class="op">=</span><span class="va">freqmat</span>, theta<span class="op">=</span><span class="fl">45</span>, phi<span class="op">=</span><span class="fl">20</span>, contour <span class="op">=</span><span class="cn">F</span>,</span>
<span>                xlab<span class="op">=</span><span class="st">"Allele frequency"</span>, zlab<span class="op">=</span><span class="st">"Number of populations"</span>,</span>
<span>                ylab<span class="op">=</span><span class="st">"Generations"</span><span class="op">)</span></span></code></pre></div>
<p><img src="popgen_drift_files/figure-html/unnamed-chunk-17-1.png" width="700"></p>
<div class="sourceCode" id="cb30"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Plotting selected generations:</span></span>
<span><span class="co">########## </span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/frame.html" class="external-link">plot.new</a></span><span class="op">(</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span>oma<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span>,<span class="fl">1</span><span class="op">)</span>, mfrow<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span><span class="op">)</span>, mar<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">2</span>,<span class="fl">2</span>,<span class="fl">2</span>,<span class="fl">0</span><span class="op">)</span><span class="op">)</span></span>
<span></span>
<span><span class="va">pfx</span> <span class="op">&lt;-</span> <span class="kw">function</span><span class="op">(</span><span class="va">gen</span><span class="op">)</span><span class="op">{</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/graphics/frame.html" class="external-link">plot.new</a></span><span class="op">(</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/graphics/plot.window.html" class="external-link">plot.window</a></span><span class="op">(</span>xlim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">33</span><span class="op">)</span>, ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">15</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/graphics/axis.html" class="external-link">axis</a></span><span class="op">(</span><span class="fl">1</span>, at<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">4</span>, <span class="fl">36</span>, by<span class="op">=</span><span class="fl">4</span><span class="op">)</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/graphics/axis.html" class="external-link">axis</a></span><span class="op">(</span><span class="fl">2</span>, at<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span><span class="op">-</span><span class="fl">2</span>, <span class="fl">16</span>, by<span class="op">=</span><span class="fl">2</span><span class="op">)</span>, las<span class="op">=</span><span class="fl">1</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span>x<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">16</span>,<span class="fl">16</span><span class="op">)</span>, y<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fl">18</span><span class="op">)</span>, lwd<span class="op">=</span><span class="fl">5</span>, col<span class="op">=</span><span class="st">"gray60"</span><span class="op">)</span></span>
<span>    <span class="fu"><a href="https://rdrr.io/r/graphics/title.html" class="external-link">title</a></span><span class="op">(</span>main <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/paste.html" class="external-link">paste</a></span><span class="op">(</span><span class="st">"After"</span>, <span class="va">gen</span>, <span class="fu"><a href="https://rdrr.io/r/base/ifelse.html" class="external-link">ifelse</a></span><span class="op">(</span><span class="va">gen</span> <span class="op">==</span> <span class="fl">1</span>, <span class="st">"gen"</span>, <span class="st">"gens"</span><span class="op">)</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="op">}</span></span>
<span></span>
<span><span class="co"># Expectation after 1 generation of drift:</span></span>
<span><span class="fu">pfx</span><span class="op">(</span><span class="fl">1</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span>x<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">32</span>, y<span class="op">=</span><span class="va">freqmat</span><span class="op">[</span>,<span class="fl">1</span><span class="op">]</span>, pch<span class="op">=</span><span class="fl">21</span>, bg<span class="op">=</span><span class="st">"red"</span>, cex<span class="op">=</span><span class="fl">1.5</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Expectation after 5 generations of drift</span></span>
<span><span class="fu">pfx</span><span class="op">(</span><span class="fl">5</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span>x<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">32</span>, y<span class="op">=</span><span class="va">freqmat</span><span class="op">[</span>,<span class="fl">5</span><span class="op">]</span>, pch<span class="op">=</span><span class="fl">21</span>, bg<span class="op">=</span><span class="st">"red"</span>, cex<span class="op">=</span><span class="fl">1.5</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Expectation after 10 generations of drift</span></span>
<span><span class="fu">pfx</span><span class="op">(</span><span class="fl">10</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span>x<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">32</span>, y<span class="op">=</span><span class="va">freqmat</span><span class="op">[</span>,<span class="fl">10</span><span class="op">]</span>, pch<span class="op">=</span><span class="fl">21</span>, bg<span class="op">=</span><span class="st">"red"</span>, cex<span class="op">=</span><span class="fl">1.5</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Expectation after 15 generations of drift</span></span>
<span><span class="fu">pfx</span><span class="op">(</span><span class="fl">15</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span>x<span class="op">=</span><span class="fl">0</span><span class="op">:</span><span class="fl">32</span>, y<span class="op">=</span><span class="va">freqmat</span><span class="op">[</span>,<span class="fl">15</span><span class="op">]</span>, pch<span class="op">=</span><span class="fl">21</span>, bg<span class="op">=</span><span class="st">"red"</span>, cex<span class="op">=</span><span class="fl">1.5</span><span class="op">)</span></span></code></pre></div>
<p><img src="popgen_drift_files/figure-html/unnamed-chunk-17-2.png" width="700"></p>
<div class="sourceCode" id="cb31"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Restoring old par() configs:</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/par.html" class="external-link">par</a></span><span class="op">(</span><span class="va">oldpar</span><span class="op">)</span></span></code></pre></div>
<p>The above visually resembles figure 6 in Buri (1956) – but please
remember this is an <em>analytical expectation</em>.</p>
<p>A little more on the history of this mathematical model can be found
in the initial parts of Tran <em>et al</em> (2013) – but note that the
mathematics that is developed in the later parts of the paper may be
challenging. The original references on the Wright-Fisher population
model are Fisher (1922) and Wright (1931).</p>
<hr>
<div class="section level3">
<h3 id="references">References:<a class="anchor" aria-label="anchor" href="#references"></a>
</h3>
<p>Buri, P. (1956). Gene frequency in small populations of mutant
Drosophila. Evolution, 367-402.</p>
<p>Fisher RA (1922) On the dominance ratio. Proc. R. Soc. Edinb
42:321–341</p>
<p>Kimura, M. (1955). Solution of a process of random genetic drift with
a continuous model. Proceedings of the National Academy of Sciences of
the United States of America, 41(3), 144.</p>
<p>Tran, T. D., Hofrichter, J., &amp; Jost, J. (2013). An introduction
to the mathematical structure of the Wright–Fisher model of population
genetics. Theory in Biosciences, 132(2), 73-82. <strong>[good for the
historical review, math can be challenging]</strong></p>
<p>Waples, R. S. (2022). What is Ne, anyway?. Journal of Heredity,
113(4), 371–379.</p>
<p>Wright S (1931) Evolution in Mendelian populations. Genetics
16:97–159</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Matheus Januario, Jennifer Auler, Andressa Viol, Daniel Rabosky.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
