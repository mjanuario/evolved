<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>Introduction to evolutionary genetics • evolved</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Introduction to evolutionary genetics">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-primary" data-bs-theme="dark" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">evolved</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="Released version">1.0.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../index.html"><span class="fa fa-home"></span> Home</a></li>
<li class="nav-item"><a class="nav-link" href="../reference/index.html"><span class="fa fa-book"></span> Reference</a></li>
<li class="active nav-item"><a class="nav-link" href="../articles/index.html"><span class="fa fa-book-open"></span> Vignettes &amp; Tutorials</a></li>
<li class="nav-item"><a class="nav-link" href="../news/index.html"><span class="fa fa-newspaper"></span> News</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/mjanuario/evolved" aria-label="GitHub repository"><span class="fa fa-github"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>Introduction to evolutionary genetics</h1>
                        <h4 data-toc-skip class="author">Matheus
Januario, Andressa Viol, and Daniel Rabosky</h4>
            
            <h4 data-toc-skip class="date">Jan 2024</h4>
      
      <small class="dont-index">Source: <a href="https://github.com/mjanuario/evolved/blob/v1.0.23/vignettes/popgen_intro.Rmd" class="external-link"><code>vignettes/popgen_intro.Rmd</code></a></small>
      <div class="d-none name"><code>popgen_intro.Rmd</code></div>
    </div>

    
    
<div class="section level2">
<h2 id="learning-objectives">Learning objectives<a class="anchor" aria-label="anchor" href="#learning-objectives"></a>
</h2>
<ol style="list-style-type: decimal">
<li>Simple math notation</li>
<li>Probability of independent events</li>
<li>Random number generators and density/mass probability functions</li>
<li>Malthusian growth</li>
<li>Mendelian genetics and Hardy-Weinberg Equilibrium at a single
locus</li>
<li>Heterozygosity</li>
<li>HWE, deleterious alleles, and mutation</li>
<li>Mendelian genetics at multiple loci</li>
<li>Describing genetic variation in DNA segments</li>
</ol>
<p>First, we load our packages:</p>
<div class="sourceCode" id="cb1"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="kw"><a href="https://rdrr.io/r/base/library.html" class="external-link">library</a></span><span class="op">(</span><span class="va"><a href="https://github.com/mjanuario/evolved" class="external-link">evolved</a></span><span class="op">)</span></span></code></pre></div>
<div class="section level3">
<h3 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h3>
<p>Since you are now familiar with R, we can proceed to our first lab in
evolutionary processes. Today, we will focus on the fundamental entity
of evolution: genes. We will first review how the laws of probability
can be used to build very simple (but powerful!) models of genotypic
evolutionary change. Then we will calculate some properties of and test
hypotheses about such change. We will finish the lab by introducing
methods to measure the genetic diversity generated by such
processes.</p>
<p>It is important to note that we will change conventions quickly in
this tutorial, meaning that the same letter might have different
meanings in different equations, so be mindful of which section you are
in.</p>
</div>
<div class="section level3">
<h3 id="simple-math-notation">Simple math notation<a class="anchor" aria-label="anchor" href="#simple-math-notation"></a>
</h3>
<p>The first notation we will introduce is the summation, denoted by the
uppercase Greek letter sigma
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mo>∑</mo><mrow></mrow></msub><annotation encoding="application/x-tex">\sum_{}</annotation></semantics></math>).
Usually, the subscript of this letter tells you from which element to
start the operation, and the upperscript tells you at which element the
summation ends. For instance the notation:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
\sum_{i=1}^{n}x_i
\end{equation}</annotation></semantics></math></p>
<p>indicates a summation of elements starting at the first (i = 1) and
going until the n-th element (the upperscript). It is left implicit in
this notation that the summation is made element by element, but
sometimes this information might appear explicitly. If you are familiar
with R’s <code>for</code> loops, it may be useful to think of the
summation as representing a <code>for</code> loop that iterates from the
sub- to the upperscript, each time applying the operation and adding its
result to the running sum.</p>
<p>A familiar example is the formula to calculate the arithmetic
mean:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mover><mi>X</mi><mo accent="true">‾</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>×</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
\bar{X} = \frac{1}{n} \times \sum_{i=1}^{n}x_i
\end{equation}</annotation></semantics></math></p>
<p>As another example, take the following equation, which describes the
expected number of heterozygotes in a diploid population with
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
alleles in Hardy-Weinberg equilibrium:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>;</mo><mi>i</mi><mo>≠</mo><mi>j</mi></mrow><mi>k</mi></munderover><msub><mi>p</mi><mi>i</mi></msub><msub><mi>p</mi><mi>j</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
H = \sum_{i=1 ; i\neq{j}}^{k}p_ip_j
\end{equation}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>k</mi><annotation encoding="application/x-tex">k</annotation></semantics></math>
is the number of alleles, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>i</mi></msub><annotation encoding="application/x-tex">p_i</annotation></semantics></math>
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>p</mi><mi>j</mi></msub><annotation encoding="application/x-tex">p_j</annotation></semantics></math>
are the frequencies of the
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>i</mi><annotation encoding="application/x-tex">i</annotation></semantics></math>th
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>j</mi><annotation encoding="application/x-tex">j</annotation></semantics></math>th
alleles. Note that on the right side of the equality, we sum the product
of all allele frequencies. The inequality
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>≠</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i\neq{j}</annotation></semantics></math>
tells you to <em>not</em> apply the summation when
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow><annotation encoding="application/x-tex">i=j</annotation></semantics></math>.
This kind of explicit information may appear in a summation.</p>
<p>So, in the case of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">k=3</annotation></semantics></math>,
we would have the following equation:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>H</mi><mrow><mi>k</mi><mo>=</mo><mn>3</mn></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn><mo>;</mo><mi>i</mi><mo>≠</mo><mi>j</mi></mrow><mn>3</mn></msubsup><msub><mi>p</mi><mi>i</mi></msub><msub><mi>p</mi><mi>j</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo>×</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo>×</mo><msub><mi>p</mi><mn>3</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo>×</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo>×</mo><msub><mi>p</mi><mn>3</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mn>3</mn></msub><mo>×</mo><msub><mi>p</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>p</mi><mn>3</mn></msub><mo>×</mo><msub><mi>p</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">H_{k=3} = \sum_{i=1 ; i\neq{j}}^{3}p_ip_j = (p_1 \times p_2) + (p_1 \times p_3) + (p_2 \times p_1) + (p_2 \times p_3) +  (p_3 \times p_1) + (p_3 \times p_2)</annotation></semantics></math></p>
<p>Just for the sake of completion, one could also say that:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>H</mi><mo>=</mo><mn>1</mn><mo>−</mo><mi>G</mi><mo>=</mo><mn>1</mn><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></msubsup><msubsup><mi>p</mi><mi>i</mi><mn>2</mn></msubsup><mo stretchy="true" form="postfix">)</mo></mrow></mrow><annotation encoding="application/x-tex">H = 1-G = 1- (\sum_{i=1}^{k}p_i^2)</annotation></semantics></math></p>
<p>There is an equivalent of the summation for multiplication, and it is
symbolized by the uppercase Greek letter pi
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mo>∏</mo><mrow></mrow></msub><annotation encoding="application/x-tex">\prod_{}</annotation></semantics></math>).
So, the probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>P</mi><annotation encoding="application/x-tex">P</annotation></semantics></math>
of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
independent events
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>,
each having the same probability
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>P</mi><mi>v</mi></msub><annotation encoding="application/x-tex">P_v</annotation></semantics></math>
is:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo>=</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><msub><mi>P</mi><mi>v</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
P = \prod_{i=1}^{n}P_{v}
\end{equation}</annotation></semantics></math></p>
<p>With
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>v</mi><annotation encoding="application/x-tex">v</annotation></semantics></math>
representing each event. Note that the upper- and subscript are read in
the same way as in the summation.</p>
</div>
<div class="section level3">
<h3 id="probability-of-independent-events">Probability of independent events<a class="anchor" aria-label="anchor" href="#probability-of-independent-events"></a>
</h3>
<p>The joint probability of independent events is the multiplication of
each respective probability (a quick video recap on that <a href="https://www.youtube.com/watch?v=LS-_ihDKr2M" class="external-link">here</a>).</p>
<p>So, the probability of seeing “snake eyes” (i.e. two “ones”) when you
throw two dice is:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mn>1</mn><mn>6</mn></mfrac><mo>×</mo><mfrac><mn>1</mn><mn>6</mn></mfrac><mo>=</mo><munderover><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mi>v</mi></mrow><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow></munderover><mfrac><mn>1</mn><mn>6</mn></mfrac><mo>=</mo><mfrac><mn>1</mn><mn>36</mn></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}
\frac{1}{6} \times \frac{1}{6} = \prod_{i=v}^{n=2} \frac{1}{6} = \frac{1}{36}
\end{equation}</annotation></semantics></math></p>
<p>The notation in the middle equality above might seem overly
complicated when compared to the left side of the equality, but the
compactness of this notation becomes clear when we want to multiply many
elements. R has functions that allow you to “throw dice” and study the
probability of events. These are the functions that generate random
numbers from probability functions.</p>
</div>
<div class="section level3">
<h3 id="random-number-generators-and-densitymass-probability-functions">Random number generators and density/mass probability functions<a class="anchor" aria-label="anchor" href="#random-number-generators-and-densitymass-probability-functions"></a>
</h3>
<p>Using functions that generate random numbers, we can simulate much
more than just coins and dice. R has functions that generate random
draws from famous probability distributions.</p>
<p>To explore this concept, we will focus on one of these famous
distributions: the <a href="https://www.youtube.com/watch?v=8idr1WZ1A7Q" class="external-link">binomial
distribution</a>. The binomial distribution applies for samples of
events that have a binomial outcome, such as coin flips which result in
either a “heads” or “tails” outcome. In the jargon of the field, we call
one of these outcomes a “success” and the other one a “failure”; this
makes more sense in the coin flip analogy if we imagine that we are
using the coin to determine the result of some outcome, and one of the
sides has the more favorable outcome (e.g. eat a piece of chocolate only
when the coin lands on heads, no chocolate on tails).</p>
<p>The binomial distribution has two major properties:</p>
<ol style="list-style-type: upper-roman">
<li>it counts the number of “successes” resulting from a sample of
binomial events</li>
<li>the probability of success is the same between events</li>
</ol>
<p>The binomial distribution is therefore a distribution of integers
that each represent <em>how many successes there were within a sample of
binomial events</em>. The distribution is made by taking many repeated
such samples. Each time we generate a random number from a binomial
distribution, we are generating an integer
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
between 0 (no successes occurred) and the total number of coin flips
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
(only successes occurred). In the coin tossing example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
is equivalent to counting heads out of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
coin tosses.</p>
<p>Like all probability functions, the binomial distribution has certain
parameters. These are:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>,
the probability of success for a single binary event, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>,
the total number of binary events. In the coin flip example,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
would be 0.5, representing a 50% chance of getting heads.
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
would be however many times we flip the coin.</p>
<p>Let’s simulate a coin flip. Recall that the binomial distribution
outputs the number of successes from a sample of events, so this is what
each generated random number represents.</p>
<div class="sourceCode" id="cb2"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># Define how many samples we want:</span></span>
<span><span class="va">rr</span> <span class="op">&lt;-</span> <span class="fl">10000</span></span></code></pre></div>
<p>We use the <code>rbinom</code> function to randomly generate numbers
from the binomial distribution. <code>rbinom</code> is in the r-family
of functions, the collection of functions that randomly generate numbers
from probability distributions.</p>
<div class="sourceCode" id="cb3"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">binom_nbrs</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">rbinom</a></span><span class="op">(</span>n <span class="op">=</span> <span class="va">rr</span>, size <span class="op">=</span> <span class="fl">10</span>, prob <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span>  <span class="co"># taking 10000 samples of 10</span></span></code></pre></div>
<p>A potential point of confusion is that, in <code>rbinom</code>, the
argument <code>size</code> represents the parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
discussed above, while the argument <code>n</code> actually represents
the total number of times we repeated sampling. The argument
<code>prob</code> represents the parameter
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>p</mi><annotation encoding="application/x-tex">p</annotation></semantics></math>
discussed above, the probability of success – much more straightforward.
The line of code above represents flipping a coin (with a 50% chance of
heads) 10 times and counting the number of heads flipped a total of
<code>rr</code> times.</p>
<p>If we check what the object <code>binom_nbrs</code> contains, we will
see…</p>
<div class="sourceCode" id="cb4"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/utils/head.html" class="external-link">head</a></span><span class="op">(</span><span class="va">binom_nbrs</span>, <span class="fl">10</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">##  [1] 3 7 5 3 1 5 5 4 6 6</span></span></code></pre>
<p>… a bunch of integers between 0 and 10. Each of these integers
represents the number of heads flipped in a sample of 10 coin
tosses.</p>
<p>As the binomial is a discrete probability function, it is meaningful
to tabulate the frequencies of each number we got from the random draw
we just made:</p>
<div class="sourceCode" id="cb6"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">binom_nbrs</span><span class="op">)</span></span></code></pre></div>
<pre><code><span><span class="co">## binom_nbrs</span></span>
<span><span class="co">##    0    1    2    3    4    5    6    7    8    9   10 </span></span>
<span><span class="co">##    9   84  390 1191 2050 2437 2118 1182  439   92    8</span></span></code></pre>
<p>We can also plot what we did very easily.</p>
<div class="sourceCode" id="cb8"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">binom_nbrs</span><span class="op">)</span>,</span>
<span>  ylab<span class="op">=</span><span class="st">"Frequency"</span>, xlab<span class="op">=</span><span class="st">"Number of successes"</span><span class="op">)</span></span></code></pre></div>
<p><img src="popgen_intro_files/figure-html/unnamed-chunk-6-1.png" class="r-plt" alt="" width="700"></p>
<p>Above are the random numbers we generated – i.e., the stochastic
realizations of the process that follows the distribution we chose. Each
number represents the summation of the number of successes per sample.
<em>But</em> what if instead of having a stochastic realization of the
binomial process, we wanted to know what is the fixed probability
associated with each specific number of successes?</p>
<p>For this, we would use the d-family of functions! These calculate the
probability density associated with an event. An event in this case is a
number of successes. For instance, to directly calculate the probability
of observing, say, 3 heads out of a sample of 10 coin tosses, we would
write:</p>
<div class="sourceCode" id="cb9"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">P_x3_s10_p0.5</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/Binomial.html" class="external-link">dbinom</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">3</span>, size <span class="op">=</span> <span class="fl">10</span>, prob <span class="op">=</span> <span class="fl">0.5</span><span class="op">)</span> </span>
<span><span class="co"># x is the integer value we want to know the probability density of</span></span>
<span></span>
<span><span class="va">P_x3_s10_p0.5</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.1171875</span></span></code></pre>
<p>This function basically just applies the probability mass function of
the binomial distribution, which is</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>x</mi></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>n</mi><mi>x</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><msup><mi>p</mi><mi>x</mi></msup><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="true" form="postfix">)</mo></mrow><mrow><mi>n</mi><mo>−</mo><mi>x</mi></mrow></msup></mrow><annotation encoding="application/x-tex">\begin{equation}
P_x = \binom{n}{x} p^x (1-p)^{n-x}
\end{equation}</annotation></semantics></math></p>
<p>with:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mo stretchy="true" form="prefix">(</mo><mfrac linethickness="0"><mi>n</mi><mi>x</mi></mfrac><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>n</mi><mi>!</mi></mrow><mrow><mi>x</mi><mi>!</mi><mrow><mo stretchy="true" form="prefix">(</mo><mi>n</mi><mo>−</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><mi>!</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\binom{n}{x} = \frac{n!}{x!(n-x)!}</annotation></semantics></math></p>
<p>Knowing that <code>dinom</code> is simply using the function written
above, you could manually calculate the expected probability density for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">x=3</annotation></semantics></math>,
and check to make sure it is the same as what <code>dbinom</code> gives
you. To do that, use equation (6) and substitute
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>
with 10 and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
with 3 – you should get exactly the same number as the output of
<code>dbinom</code>, which is 0.1171875.</p>
<p>There is a difference here between the stochastic realization of a
process, acquired with <code>rbinom</code>, and the theoretically
expected outcome of a process, acquired with <code>dbinom</code>. If we
draw many random numbers, we should be able to approximate the expected
probability by calculating the proportion of each outcome.</p>
<div class="sourceCode" id="cb11"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># comparing the stochastic realization of x = 3 with the expectation for x = 3</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">binom_nbrs</span><span class="op">)</span><span class="op">[</span><span class="fl">4</span><span class="op">]</span> <span class="op">/</span> <span class="va">rr</span> <span class="co">#why the division?</span></span></code></pre></div>
<pre><code><span><span class="co">##      3 </span></span>
<span><span class="co">## 0.1191</span></span></code></pre>
<div class="sourceCode" id="cb13"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">P_x3_s10_p0.5</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.1171875</span></span></code></pre>
<p>What do you think? Is it a good approximation? How could we improve
it?</p>
<p>We can also plot the random draws we made:</p>
<div class="sourceCode" id="cb15"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span></span>
<span>  <span class="fu"><a href="https://rdrr.io/r/base/table.html" class="external-link">table</a></span><span class="op">(</span><span class="va">binom_nbrs</span><span class="op">)</span><span class="op">/</span><span class="va">rr</span>, </span>
<span>  ylab<span class="op">=</span><span class="st">"Probability"</span>, xlab<span class="op">=</span><span class="st">"Number of heads"</span><span class="op">)</span></span>
<span></span>
<span><span class="co"># Finally, we can mark the probability we are interested in</span></span>
<span><span class="co"># by using a red dot in our plot:</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/points.html" class="external-link">points</a></span><span class="op">(</span>x <span class="op">=</span> <span class="fl">3</span>, y <span class="op">=</span> <span class="va">P_x3_s10_p0.5</span>, col <span class="op">=</span> <span class="st">"red"</span>, cex <span class="op">=</span> <span class="fl">2</span><span class="op">)</span></span></code></pre></div>
<p><img src="popgen_intro_files/figure-html/unnamed-chunk-9-1.png" class="r-plt" alt="" width="700"></p>
</div>
<div class="section level3">
<h3 id="malthusian-growth">Malthusian growth<a class="anchor" aria-label="anchor" href="#malthusian-growth"></a>
</h3>
<p>The idea of geometric/exponential/Malthusian growth is of major
importance for evolutionary biology. You have probably learnt of this
concept before, but we will reiterate it here. Although often called
“Malthusian growth”, the basic analytic approach was first developed by
Euler and published in 1748. He modeled population growth with equation
(7):</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>N</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>1</mn><mo>+</mo><mi>x</mi><mo stretchy="true" form="postfix">)</mo></mrow><msub><mi>N</mi><mi>t</mi></msub></mrow><annotation encoding="application/x-tex">\begin{equation}
N_{t+1} = (1 + x)N_t
\end{equation}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>x</mi><annotation encoding="application/x-tex">x</annotation></semantics></math>
is the growth rate of the population or the fractional increase per
year,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math>
is the population size (in number of individuals), and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>t</mi><annotation encoding="application/x-tex">t</annotation></semantics></math>
is time.</p>
<div class="section level4">
<h4 id="calculating-and-visualizing-exponential-growth-in-r">Calculating and visualizing exponential growth in R<a class="anchor" aria-label="anchor" href="#calculating-and-visualizing-exponential-growth-in-r"></a>
</h4>
<p>Instead of relying on a function to determine population size in the
future, we can simulate population growth across time.</p>
<p>First we decide on an initial value for our population size. This is
the number of hermaphrodite individuals, or the number of reproductive
females in the population.</p>
<div class="sourceCode" id="cb16"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">popsize</span> <span class="op">&lt;-</span> <span class="fl">10</span></span></code></pre></div>
<p>Let’s also construct a vector to store time.</p>
<div class="sourceCode" id="cb17"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">time</span> <span class="op">&lt;-</span> <span class="fl">0</span></span></code></pre></div>
<p>We need to decide on a value for
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>R</mi><annotation encoding="application/x-tex">R</annotation></semantics></math>.</p>
<div class="sourceCode" id="cb18"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">R</span> <span class="op">&lt;-</span> <span class="fl">1.05</span></span></code></pre></div>
<p>We also have to decide for how far in time our projections of
population size will go.</p>
<div class="sourceCode" id="cb19"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">tmax</span> <span class="op">&lt;-</span> <span class="fl">100</span> <span class="co"># this is the number of generations</span></span></code></pre></div>
<p>Let’s also create a vector that stores the generations we will
simulate through.</p>
<div class="sourceCode" id="cb20"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">all_generations</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html" class="external-link">seq</a></span><span class="op">(</span>from <span class="op">=</span> <span class="fl">1</span>, to <span class="op">=</span> <span class="va">tmax</span>, by <span class="op">=</span> <span class="fl">1</span><span class="op">)</span></span></code></pre></div>
<p>Now we will construct what in programming is called a <em>loop</em>.
This is just a series of very similar steps repeated. It is like running
the same chunk of code again and again, but with small changes in inputs
or parameter values (an explanation can be found <a href="https://www.youtube.com/watch?v=wxds6MAtUQ0&amp;t=2s" class="external-link">here</a>).
We create a loop as below.</p>
<div class="sourceCode" id="cb21"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># For each generation, beginning in the generation = 1 and:</span></span>
<span><span class="kw">for</span><span class="op">(</span><span class="va">generation</span> <span class="kw">in</span> <span class="va">all_generations</span><span class="op">)</span><span class="op">{</span> </span>
<span>  </span>
<span>  <span class="va">N_t</span> <span class="op">&lt;-</span> <span class="va">popsize</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">popsize</span><span class="op">)</span><span class="op">]</span> <span class="co"># by indexing </span></span>
<span>  <span class="co"># the vector in this way (i.e. using "[length()]"),</span></span>
<span>  <span class="co"># we guarantee we are always taking the last value of </span></span>
<span>  <span class="co"># this vector.</span></span>
<span>  </span>
<span>  <span class="va">N_t_plus_one</span> <span class="op">&lt;-</span> <span class="va">N_t</span> <span class="op">*</span> <span class="va">R</span> <span class="co"># this is the application of Euler's formula</span></span>
<span>  </span>
<span>  <span class="co">#Now, let's store the population size at that generation:</span></span>
<span>  <span class="va">popsize</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">popsize</span>, <span class="va">N_t_plus_one</span><span class="op">)</span></span>
<span>  </span>
<span>  <span class="co">#let's not forget to record the time that we are on:</span></span>
<span>  <span class="va">time</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="va">time</span>, <span class="va">generation</span><span class="op">)</span> </span>
<span><span class="op">}</span></span></code></pre></div>
<p>Notice that the way our loop works is completely dependent on the way
we set up <strong>all objects</strong> (i.e., <code>popsize</code>,
<code>time</code>, <code>R</code>, <code>tmax</code>, and so on) before.
If you change the loop or change how these objects are
structured/organized, your code may return an error message (or not give
you the right result). It is safe though to change the numeric values
<em>in</em> those objects to explore how exponential growth behaves at
different values.</p>
<p>Now, we will visualize the results of the simulation we just did.</p>
<p>Let’s first create an empty plot, which includes providing the
numerical range of the x and y axes of the plot. Then, we will add a
line describing the size of the population over time.</p>
<div class="sourceCode" id="cb22"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co">#</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot</a></span><span class="op">(</span><span class="cn">NA</span>, xlim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="va">tmax</span><span class="op">)</span>, ylim<span class="op">=</span><span class="fu"><a href="https://rdrr.io/r/base/c.html" class="external-link">c</a></span><span class="op">(</span><span class="fl">0</span>,<span class="fl">1500</span><span class="op">)</span>,</span>
<span>     xlab<span class="op">=</span><span class="st">"time"</span>, ylab<span class="op">=</span><span class="st">"Population size"</span>,</span>
<span>     main<span class="op">=</span><span class="st">"Malthusian growth"</span><span class="op">)</span></span>
<span><span class="fu"><a href="https://rdrr.io/r/graphics/lines.html" class="external-link">lines</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">time</span>, y <span class="op">=</span> <span class="va">popsize</span>, col <span class="op">=</span> <span class="st">"blue"</span>, lwd <span class="op">=</span> <span class="fl">3</span><span class="op">)</span></span></code></pre></div>
<p><img src="popgen_intro_files/figure-html/unnamed-chunk-16-1.png" class="r-plt" alt="" width="700"></p>
<p>Try to change the numbers inside the arguments <code>xlim</code> and
<code>ylim</code>. How does this change the plot?</p>
<p>Now, make a plot of exponential growth in four populations: one where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R &lt; 1</annotation></semantics></math>,
one where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R = 1</annotation></semantics></math>,
one where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>&gt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">R &gt; 1</annotation></semantics></math>,
and one where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>&gt;</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">R &gt; x</annotation></semantics></math>,
where x is a number of your choice that must be greater than 1. Color
the populations using increasing darker shades of your chosen color.
(Names of colors in R can be found <a href="http://applied-r.com/r-color-tables/" class="external-link"><strong>here</strong></a>).
Choose x and y limits (arguments <code>xlim</code> and
<code>ylim</code>, respectively, in the <code><a href="https://rdrr.io/r/graphics/plot.default.html" class="external-link">plot()</a></code> function)
that you think best describes qualitatively the difference(s) between
the 4 lines.</p>
<p>Repeat the same plot as above, but this time plot the y axis on a log
scale.</p>
</div>
</div>
<div class="section level3">
<h3 id="mendelian-genetics-and-hardy-weinberg-equilibrium-hwe-at-a-single-locus">Mendelian genetics and Hardy-Weinberg Equilibrium (HWE) at a single
locus<a class="anchor" aria-label="anchor" href="#mendelian-genetics-and-hardy-weinberg-equilibrium-hwe-at-a-single-locus"></a>
</h3>
<p>We will now use simulations to test if the observed set of genotype
counts is consistent with what we would see if we sampled genotypes at
random. We will first create a null pattern using R functions, then we
will contrast this pattern with the observed genotype frequencies and
compare them to expectations under Hardy-Weinberg equilibrium
(hereafter, HWE, Hardy, 1908; Weinberg, 1908). For a historical
perspective on HWE, we recommend reading Mayo (2008).</p>
<p>For the purposes of this lab, we will look to a bear population in
Canada.</p>
<div class="section level4">
<h4 id="kermode-bear-from-british-columbia">Kermode bear from British Columbia<a class="anchor" aria-label="anchor" href="#kermode-bear-from-british-columbia"></a>
</h4>
<p>Hedrick &amp; Ritland (2012) studied a population of <em>Ursus
americanus</em> where a “single nucleotide change from G to A, resulting
in the replacement of Tyr to Cys at codon 298 in the melanocortin 1
receptor gene (mc1r)” created a whole new phenotype related to color:
the “Spirit bear” variety (see figure 1, from Hedrick &amp; Ritland
(2012)).</p>
<div class="float">
<img src="spirit_bear.png" alt="A white mother Spirit bear and a black cub offspring; the father must have been black and the cub is a heterozygote for the coat color polymorphism (photo mod. from Hedrick and Ritland (2012)"><div class="figcaption">A white mother Spirit bear and a black cub
offspring; the father must have been black and the cub is a heterozygote
for the coat color polymorphism (photo mod. from Hedrick and Ritland
(2012)</div>
</div>
<p>In a previous study (Ritland <em>et al</em>, 2001), the following
frequencies of genotypes were observed: 42 individuals with the dominant
homozygote phenotype, 24 heterozygotes, and 21 recessive genotypes.
Hedrick &amp; Ritland (2012) asks: are the Spirit bear frequencies a
result of neutral processes? This is equivalent of asking <em>is this
genotype frequency a simple reflex of Hardy-Weinberg Equilibrium
(HWE)?</em></p>
</div>
<div class="section level4">
<h4 id="calculating-allele-frequencies-from-genotypes">Calculating allele frequencies from genotypes<a class="anchor" aria-label="anchor" href="#calculating-allele-frequencies-from-genotypes"></a>
</h4>
<p>Let’s start our investigation with a simpler question: what is the
allele frequency of this population? To have an idea, we would need to
count each allele’s relative frequency in the population genetic
pool.</p>
<p>Let’s consider
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mn>1</mn></msub><annotation encoding="application/x-tex">A_1</annotation></semantics></math>
(the dominant allele): first we would need to count the number of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>A</mi><mn>1</mn></msub><annotation encoding="application/x-tex">A_1</annotation></semantics></math>
alleles by finding out (a) how many copies of that allele each genotype
carries, and then (b) multiplying that by the number of individuals with
each relevant genotype. So, applying this to the data on the Spirit
bear:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>42</mn><mo>*</mo><mn>2</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>24</mn><mo>*</mo><mn>1</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>21</mn><mo>*</mo><mn>0</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>108</mn></mrow><annotation encoding="application/x-tex">counts(A_1) = (42 * 2) + (24 *1) + (21*0) = 108</annotation></semantics></math></p>
<p>We sum all these terms and divide this sum by the total number of
alleles in the population to get the allele frequency. As this gene has
only two alleles, we get:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow><mrow><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>+</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi>s</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>A</mi><mn>2</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">\begin{equation}
f(A_1) = \frac{counts(A_1)}{counts(A_1) + counts(A_2)} 
\end{equation}</annotation></semantics></math></p>
<p>So:
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mfrac><mn>108</mn><mrow><mo stretchy="true" form="prefix">(</mo><mn>108</mn><mo>+</mo><mn>66</mn><mo stretchy="true" form="postfix">)</mo></mrow></mfrac><mo>=</mo><mn>0.617</mn></mrow><annotation encoding="application/x-tex">f(A_1) = \frac{108}{(108+66)} = 0.617</annotation></semantics></math></p>
</div>
<div class="section level4">
<h4 id="a-statistical-approach-to-test-for-hwe-and-a-given-allele-frequency">A statistical approach to test for HWE and a given allele
frequency<a class="anchor" aria-label="anchor" href="#a-statistical-approach-to-test-for-hwe-and-a-given-allele-frequency"></a>
</h4>
<p>Using the allele frequencies we calculated above, we can use
statistics to answer the question posed by Hedrick &amp; Ritland
(2012).</p>
<p>To do this, we will do a test that resembles a chi-square test. The
first step is to decide upon a test statistic – i.e., some measure we
care about. For instance, we could pick the sum of the squared
difference between each observed genotype frequency and the HWE expected
frequency:</p>
<p><math display="block" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>=</mo><munderover><mo>∑</mo><mrow><mi>g</mi><mo>=</mo><mn>1</mn></mrow><mi>A</mi></munderover><msup><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>O</mi><mi>g</mi></msub><mo>−</mo><msub><mi>E</mi><mi>g</mi></msub><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\begin{equation}
E_{stat} = \sum_{g=1}^{A} (O_g - E_g)^2
\end{equation}</annotation></semantics></math></p>
<p>where
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>O</mi><mi>g</mi></msub><annotation encoding="application/x-tex">O_g</annotation></semantics></math>
is the observed number of individuals and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mi>g</mi></msub><annotation encoding="application/x-tex">E_g</annotation></semantics></math>
is the expected number of individuals. This calculation is performed for
each genotype
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>g</mi><annotation encoding="application/x-tex">g</annotation></semantics></math>
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>A</mi><annotation encoding="application/x-tex">A</annotation></semantics></math>
is the total number of genotypes).</p>
<p>Considering all HWE assumptions, we should expect the frequencies to
be
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>p</mi><mn>2</mn></msup><annotation encoding="application/x-tex">p^2</annotation></semantics></math>
for one homozygote,
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msup><mi>q</mi><mn>2</mn></msup><annotation encoding="application/x-tex">q^2</annotation></semantics></math>
for the second homozygote, and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn><mi>p</mi><mi>q</mi></mrow><annotation encoding="application/x-tex">2pq</annotation></semantics></math>
for the heterozygotes. As
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>=</mo><mn>0.617</mn></mrow><annotation encoding="application/x-tex">p =0.617</annotation></semantics></math>,
and
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>q</mi><mo>=</mo><mn>1</mn><mo>−</mo><mi>p</mi></mrow><annotation encoding="application/x-tex">q = 1-p</annotation></semantics></math>,
our statistic is calculated as:</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><mo>=</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>42</mn><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.38</mn><mo>*</mo><mn>87</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>24</mn><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.47</mn><mo>*</mo><mn>87</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>+</mo><msup><mrow><mo stretchy="true" form="prefix">(</mo><mn>21</mn><mo>−</mo><mrow><mo stretchy="true" form="prefix">(</mo><mn>0.15</mn><mo>*</mo><mn>87</mn><mo stretchy="true" form="postfix">)</mo></mrow><mo stretchy="true" form="postfix">)</mo></mrow><mn>2</mn></msup><mo>=</mo><mn>428.3982</mn></mrow><annotation encoding="application/x-tex">E_{stat} = (42 - (0.38 * 87))^2 + (24 - (0.47 * 87))^2 + (21 - (0.15 * 87))^2 = 428.3982</annotation></semantics></math></p>
<p><strong>Note</strong> that the value above uses the rounded allele
frequencies for simplicity. However, if you calculate such frequencies
using R, the calculation will be very precise and the lack of rounding
will change the number of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{stat}</annotation></semantics></math>.</p>
<p>Once we calculate this value, we need to know: is the value of our
statistic big enough to reject HWE? We do not know <em>yet</em>.</p>
<p>To proceed, we have to create a null distribution of our statistic of
interest
(<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{stat}</annotation></semantics></math>).
To construct the null distribution, we just have to know what would be
the distribution of our statistic of interest if all assumptions of HWE
are met. We will meet these assumptions in our simulations. Note that
this is basically the construction of a virtual Wright-Fisher population
(more details on this in future lectures).</p>
<p>To make it easier to simulate data, we will use the built-in
simulations from <code>evolved</code>, the function
<code>OneGenHWSim</code>. It takes three arguments:</p>
<p><code>n.ind</code>: the number of individuals in the population</p>
<p><code>n.sim</code>: the number of simulations you want to do</p>
<p><code>p</code>: the allele frequency of one of the two alleles</p>
<p>So, if we want to study HWE frequencies (in a Wright-Fisher) using 5
simulated populations of 100 individuals each, all having an allele
frequency
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mrow><mo stretchy="true" form="prefix">(</mo><msub><mi>A</mi><mn>1</mn></msub><mo stretchy="true" form="postfix">)</mo></mrow><mo>=</mo><mn>0.467</mn></mrow><annotation encoding="application/x-tex">f(A_1) = 0.467</annotation></semantics></math>,
we would write:</p>
<div class="sourceCode" id="cb23"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="va">sim_pops</span> <span class="op">&lt;-</span> <span class="fu"><a href="../reference/OneGenHWSim.html">OneGenHWSim</a></span><span class="op">(</span>n.ind <span class="op">=</span> <span class="fl">100</span>, n.sim <span class="op">=</span> <span class="fl">5</span>, p <span class="op">=</span> <span class="fl">0.467</span><span class="op">)</span></span>
<span></span>
<span><span class="co">#now, checking the result of our simulations:</span></span>
<span><span class="va">sim_pops</span></span></code></pre></div>
<pre><code><span><span class="co">##       A1A1 A1A2 A2A2</span></span>
<span><span class="co">## sim_1   22   49   29</span></span>
<span><span class="co">## sim_2   21   51   28</span></span>
<span><span class="co">## sim_3   23   48   29</span></span>
<span><span class="co">## sim_4   20   54   26</span></span>
<span><span class="co">## sim_5   26   41   33</span></span></code></pre>
<p>What the result above shows is a table with the number of individuals
with each genotype at the end of the simulations. We can use this to
calculate our statistic of interest. The following steps will walk you
through this process.</p>
<ol style="list-style-type: upper-roman">
<li><p>Do many simulations of populations that have the same number of
individuals and allele frequencies as the Kermode bear population
studied by Hedrick &amp; Ritland (2012).</p></li>
<li><p>Calculate
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{stat}</annotation></semantics></math>
for every single one of your many populations. A good tip here is to
remember that R is a vector calculator, so you can apply the same
operation to all elements of a column in a data frame. If you don’t
remember how R does vectorized calculations, you can check the
<em>Lab_00.pdf</em> file, or see below:</p></li>
</ol>
<div class="sourceCode" id="cb25"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># To remember how this works, let's imagine you want to </span></span>
<span><span class="co"># arbitrarily calculate (f(A1) + 3) / 4.5 for all your simulations. </span></span>
<span><span class="co">#You should run:</span></span>
<span></span>
<span><span class="va">freqs_A1</span> <span class="op">&lt;-</span> <span class="va">sim_pops</span><span class="op">$</span><span class="va">A1A1</span> <span class="op">/</span> <span class="op">(</span><span class="va">sim_pops</span><span class="op">$</span><span class="va">A1A1</span> <span class="op">+</span> <span class="va">sim_pops</span><span class="op">$</span><span class="va">A1A2</span> <span class="op">+</span> <span class="va">sim_pops</span><span class="op">$</span><span class="va">A2A2</span><span class="op">)</span></span>
<span></span>
<span><span class="va">result</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">freqs_A1</span> <span class="op">+</span> <span class="fl">3</span><span class="op">)</span> <span class="op">/</span> <span class="fl">4.5</span></span>
<span><span class="va">result</span></span></code></pre></div>
<pre><code><span><span class="co">## [1] 0.7155556 0.7133333 0.7177778 0.7111111 0.7244444</span></span></code></pre>
<div class="sourceCode" id="cb27"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span><span class="co"># the above has no biological "meaning". </span></span>
<span><span class="co"># it is just to remind you how vectorized calculation works</span></span></code></pre></div>
<ol start="3" style="list-style-type: upper-roman">
<li><p>Visualize what we did. To do this, first use the function
<code><a href="https://rdrr.io/r/graphics/hist.html" class="external-link">hist()</a></code> to plot the histogram of the set of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{stat}</annotation></semantics></math>
values that came from our simulations. This represents the distribution
of the likely values of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{stat}</annotation></semantics></math>
if the population is following HW assumptions, adjusted to the
particularities (i.e., the “parameters”) of the empirical population.
Where would the empirical (observed) value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{stat}</annotation></semantics></math>
be on the x axis?</p></li>
<li><p>Measure quantitatively the likelihood of our empirical value of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{stat}</annotation></semantics></math>
being generated by pure chance. This is equivalent of asking: <em>what
is the probability of, by pure chance alone, observing the empirical
value of our statistic (or a value even more extreme than
that)?</em></p></li>
</ol>
<p>Can you think of some very simple code that quantifies the proportion
of simulations that have an
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{stat}</annotation></semantics></math>
value equal or larger than the empirical value? Maybe one that uses a
logical test?</p>
<ol start="22" style="list-style-type: upper-alpha">
<li>The proportion of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{stat}</annotation></semantics></math>
values that are equal to or more extreme than your empirical value can
be interpreted as a “pseudo p-value”. This is a one-tailed test. The
“p-value” is called “pseudo” because we do not have a formal probability
distribution here, just an approximated distribution of
<math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><msub><mi>E</mi><mrow><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi></mrow></msub><annotation encoding="application/x-tex">E_{stat}</annotation></semantics></math>
values created by simulating data. Still, if the “pseudo p-value” is
smaller than 0.05, we usually feel confident in rejecting the null
hypothesis that the data came from a distribution analogous to the one
we simulated. Note also that because your p-value depends on the number
of simulations you did, the number of decimals you will have in your
p-value calculation will be proportional to the number of simulations
you did (i.e., you have a precision equal to 1/<code>n.sim</code>)</li>
</ol>
<ol start="6" style="list-style-type: upper-roman">
<li>Use the function <code>abline</code> to mark relevant values in your
histogram using vertical (argument <code>v</code>) or horizontal
(argument <code>h</code>) lines. Hint: make sure the line you plot is
inside the values of your axes! To manually change your axes, use the
argument <code>xlim = c(A,B)</code>, where <code>A</code> is the left
limit of your x axis, and <code>B</code> is the right limit of your x
axis.</li>
</ol>
<p>Now, use the procedure above to answer question number five:</p>
<p>The first challenge of this lab is recommended for students that feel
confident with their R skills:</p>
</div>
</div>
<div class="section level3">
<h3 id="heterozygosity">Heterozygosity<a class="anchor" aria-label="anchor" href="#heterozygosity"></a>
</h3>
<p>As defined in the lecture, “heterozygosity” might mean two
things:</p>
<ol style="list-style-type: decimal">
<li>the probability that 2 alleles sampled from a population are
different.</li>
<li>The actual frequency of heterozygotes in the population.</li>
</ol>
</div>
<div class="section level3">
<h3 id="hwe-deleterious-alleles-and-mutation">HWE, deleterious alleles, and mutation<a class="anchor" aria-label="anchor" href="#hwe-deleterious-alleles-and-mutation"></a>
</h3>

</div>
<div class="section level3">
<h3 id="mendelian-genetics-at-multiple-loci">Mendelian genetics at multiple loci<a class="anchor" aria-label="anchor" href="#mendelian-genetics-at-multiple-loci"></a>
</h3>

</div>
<div class="section level3">
<h3 id="describing-genetic-variation-in-dna-segments">Describing genetic variation in DNA segments<a class="anchor" aria-label="anchor" href="#describing-genetic-variation-in-dna-segments"></a>
</h3>
<p>As you saw in the lecture, some of the most remarkable first studies
of genetic variation are Hubby &amp; Lewontin (1966) and Lewontin &amp;
Hubby (1966). To deepen your perspective on these studies and their
historical and current applications, we recommend reading Charlesworth
<em>et al</em> (2016).</p>
<p>Genetic diversity has had an important role in the study of
biological diversity. For the purposes of this class, we will take an
extremely simplifying approach and calculate different, but simple
statistics of “genetic diversity”.</p>
<p>Consider the following aligned DNA sequences from 3 genes (genes
separated by space):</p>
<pre><code>Individual 1    ACCGTA   AAAAAT   CTTATA     
Individual 2    AGCGGA   CATAAT   CTTATA     
Individual 3    ACCGTA   AAAAAT   CTACTA     
Individual 4    ACCGGA   AAAAAT   CTACTA     </code></pre>
</div>
</div>
<div class="section level2">
<h2 id="references">References:<a class="anchor" aria-label="anchor" href="#references"></a>
</h2>
<p>Charlesworth, B., Charlesworth, D., Coyne, J. A., &amp; Langley, C.
H. (2016). Hubby and Lewontin on protein variation in natural
populations: when molecular genetics came to the rescue of population
genetics. Genetics, 203(4), 1497-1503.</p>
<p>Hardy, G. H. (1908). Mendelian proportions in a mixed population.
Science, 28, 49–50.</p>
<p>Hedrick, P. W., &amp; Ritland, K. (2012). Population genetics of the
white‐phased “Spirit” black bear of British Columbia. Evolution:
International Journal of Organic Evolution, 66(2), 305-313.</p>
<p>Hubby, J. L., &amp; Lewontin, R. C. (1966). A molecular approach to
the study of genic heterozygosity in natural populations. I. The number
of alleles at different loci in Drosophila pseudoobscura. Genetics,
54(2), 577.</p>
<p>Lewontin, R. C., &amp; Hubby, J. L. (1966). A molecular approach to
the study of genic heterozygosity in natural populations. II. Amount of
variation and degree of heterozygosity in natural populations of
Drosophila pseudoobscura. Genetics, 54(2), 595.</p>
<p>Mayo, O. (2008). A century of Hardy–Weinberg equilibrium. Twin
Research and Human Genetics, 11(3), 249-256.</p>
<p>Ritland, K., C. Newton, and H. D. Marshall. 2001. Inheritance and
population structure of the white-phased “Kermode” black bear. Curr.
Biol. 11:1468–1472.</p>
<p>Weinberg, W. (1908). Uber den Nachweis der Vererbung beim Menschen.
Jahreshefte des Vereins fur vaterlandische Naturkunde in Wurttemberg,
Stuttgart 64:369–382. [On the demonstration of inheritance in humans].
Translation by R. A. Jameson printed in D. L. Jameson (Ed.), (1977).
Benchmark papers in genetics, Volume 8: Evolutionary genetics
(pp. 115–125). Stroudsburg, PA: Dowden, Hutchinson &amp; Ross.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Matheus Januario, Jennifer Auler, Andressa Viol, Daniel Rabosky.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.2.0.</p>
</div>

    </footer>
</div>





  </body>
</html>
